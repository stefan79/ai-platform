# Spec: v0.1.0 serve client static assets and index.html

## Summary

Serve the mocked client shell from `apps/client` as static assets plus `index.html`. The UI renders a static component hierarchy with no dynamic behavior or data. The build output is served via an Nx target (using the client app output).

## Goals

- Build the client shell into static assets using `pnpx nx run client:build`.
- Serve the built client via `pnpx nx run client:serve` (or equivalent Nx target).
- Render a mocked UI that matches the specified component hierarchy.
- Keep implementation minimal and static (no runtime state, data, or network usage).
- Use Effect TS where applicable for future event-driven state and effects.

## Non-goals

- Real data, state management, or WebSocket integration.
- Backend-driven rendering or server-side rendering.
- Plugin loading, import maps, or SystemJS wiring (later milestones).

## Scope by project

### `apps/client`

- Provide a static `index.html` and bundled assets via the existing build pipeline.
- Add UI components to reflect the mocked hierarchy.
- Ensure a single-page render with all panels visible.
- Keep interactions non-functional (no toggles or actions).

### `apps/server-rest` and `apps/server-ws`

- No changes required for this milestone.
- Static hosting is provided via the client app output.

## UI component hierarchy (mocked)

1. Application Shell
- AppShell
  - Sidebar (Control Panel)
  - MainPane

2. Sidebar â€“ Control Panel (Collapsible)
- Sidebar
  - SidebarToggle
  - ThreadList
    - ThreadListItem
  - ActorPanel
  - FilePanel
  - SettingsPanel

3. Main Pane
- MainPane
  - SystemStateBar
  - ThreadHeader
    - ThreadTitle
    - ThreadActions
  - MessageTimeline
    - MessageBubble
      - MessageContent
      - MessageContextMenu
  - MessageComposer
    - ComposerInput
    - ComposerToolbar
    - CommandPalette
  - ThreadOverviewDrawer

4. Additional Panels
- MessageDetailsPanel
- SoundNotifier
- OverlayManager

## UX notes (mock UI)

- Actors configured in control panel only.
- Message styling reflects actor role only.
- Messages are immutable events (mocked UI only).
- UI reflects explicit system state, not inferred state.

## Component state model (event-driven, suggested)

Each component owns a minimal local model to enable future event-driven scenarios. State changes should be expressed as events, not direct mutations. For v0.1.0 these are placeholders only (no behavior or wiring yet).
When implementing models or effect boundaries, prefer Effect TS to encode events, state transitions, and effectful operations.
Practical Effect TS usage for this milestone:
- Use `@effect/schema` (or `Schema` from Effect) to define the state and event types for each component model.
- Use `Effect` types to represent state transitions (pure) and effectful operations (future I/O), even if they are not executed in v0.1.0.
- Keep the UI rendering from plain initialized state values; Effect programs are only type scaffolding until behavior is introduced.

- AppShell
  - state: `layoutMode` ("split" | "focused"), `activePane` ("sidebar" | "main"), `lastEventId`
  - events: `ShellLayoutChanged`, `ShellActivePaneChanged`
- Sidebar
  - state: `isCollapsed`, `activePanel` ("threads" | "actors" | "files" | "settings"), `lastEventId`
  - events: `SidebarToggled`, `SidebarPanelSelected`
- SidebarToggle
  - state: `isCollapsed`, `isEnabled`
  - events: `SidebarToggleClicked`
- ThreadList
  - state: `threads` (ids, titles), `selectedThreadId`, `filter`, `lastEventId`
  - events: `ThreadListLoaded`, `ThreadSelected`, `ThreadFilterChanged`
- ThreadListItem
  - state: `threadId`, `title`, `unreadCount`, `isSelected`
  - events: `ThreadItemSelected`, `ThreadItemMarkedRead`
- ActorPanel
  - state: `actors` (ids, names, roles), `selectedActorId`, `isEditable`
  - events: `ActorListLoaded`, `ActorSelected`, `ActorEdited`
- FilePanel
  - state: `files` (ids, names, status), `selectedFileId`, `isEditable`
  - events: `FileListLoaded`, `FileSelected`, `FileMetadataEdited`
- SettingsPanel
  - state: `settings` (key-value), `dirtyKeys`, `isEditable`
  - events: `SettingsLoaded`, `SettingChanged`, `SettingsSaved`
- MainPane
  - state: `activeThreadId`, `viewMode` ("timeline" | "details"), `lastEventId`
  - events: `MainThreadChanged`, `MainViewModeChanged`
- SystemStateBar
  - state: `systemStatus` ("ok" | "degraded" | "down"), `labels`, `lastUpdatedAt`
  - events: `SystemStateUpdated`
- ThreadHeader
  - state: `threadId`, `title`, `status`, `lastEventId`
  - events: `ThreadHeaderUpdated`
- ThreadTitle
  - state: `threadId`, `title`, `isEditable`
  - events: `ThreadTitleEdited`
- ThreadActions
  - state: `availableActions`, `lastInvokedAction`
  - events: `ThreadActionInvoked`
- MessageTimeline
  - state: `threadId`, `messageIds`, `scrollAnchor`, `lastEventId`
  - events: `TimelineLoaded`, `TimelineScrolled`
- MessageBubble
  - state: `messageId`, `actorRole`, `timestamp`, `status`
  - events: `MessageBubbleFocused`, `MessageBubbleHighlighted`
- MessageContent
  - state: `messageId`, `content`, `format` ("text" | "markdown"), `attachments`
  - events: `MessageContentUpdated`
- MessageContextMenu
  - state: `messageId`, `isOpen`, `anchor`
  - events: `MessageContextMenuOpened`, `MessageContextMenuClosed`, `MessageContextMenuAction`
- MessageComposer
  - state: `draftText`, `selectedActors`, `isSubmitting`, `lastEventId`
  - events: `ComposerDraftChanged`, `ComposerSubmitted`, `ComposerCleared`
- ComposerInput
  - state: `draftText`, `isFocused`, `cursorPosition`
  - events: `ComposerInputChanged`, `ComposerInputFocused`, `ComposerInputBlurred`
- ComposerToolbar
  - state: `availableCommands`, `activeCommandId`
  - events: `ComposerCommandSelected`
- CommandPalette
  - state: `isOpen`, `query`, `results`, `highlightedIndex`
  - events: `CommandPaletteOpened`, `CommandPaletteClosed`, `CommandPaletteQueryChanged`, `CommandPaletteResultSelected`
- ThreadOverviewDrawer
  - state: `threadId`, `isOpen`, `sections`, `activeSectionId`
  - events: `ThreadOverviewOpened`, `ThreadOverviewClosed`, `ThreadOverviewSectionSelected`
- MessageDetailsPanel
  - state: `messageId`, `isOpen`, `details`
  - events: `MessageDetailsOpened`, `MessageDetailsClosed`, `MessageDetailsUpdated`
- SoundNotifier
  - state: `isEnabled`, `lastSoundId`, `volume`
  - events: `SoundNotificationQueued`, `SoundNotificationPlayed`, `SoundSettingsChanged`
- OverlayManager
  - state: `activeOverlays`, `zStack`, `lastEventId`
  - events: `OverlayOpened`, `OverlayClosed`, `OverlayFocused`

## Rendered initial state (v0.1.0)

Each component must initialize its model with a concrete default and render directly from that state. No async loading, no event handlers, and no runtime mutations in v0.1.0. The goal is a static render that is state-driven to allow later event-driven updates.

Suggested default values (can be adjusted but must be explicit):

- AppShell: `layoutMode: "split"`, `activePane: "main"`, `lastEventId: "evt-0"`
- Sidebar: `isCollapsed: false`, `activePanel: "threads"`, `lastEventId: "evt-0"`
- SidebarToggle: `isCollapsed: false`, `isEnabled: true`
- ThreadList: `threads: [{ id: "t-1", title: "Project Alpha" }, { id: "t-2", title: "Runtime Notes" }]`, `selectedThreadId: "t-1"`, `filter: ""`, `lastEventId: "evt-0"`
- ThreadListItem: `threadId: "t-1"`, `title: "Project Alpha"`, `unreadCount: 2`, `isSelected: true`
- ActorPanel: `actors: [{ id: "a-1", name: "System", role: "system" }, { id: "a-2", name: "Operator", role: "user" }, { id: "a-3", name: "Assistant", role: "assistant" }]`, `selectedActorId: "a-3"`, `isEditable: false`
- FilePanel: `files: [{ id: "f-1", name: "design.md", status: "synced" }, { id: "f-2", name: "notes.txt", status: "draft" }]`, `selectedFileId: "f-1"`, `isEditable: false`
- SettingsPanel: `settings: { theme: "light", density: "comfortable", sound: true }`, `dirtyKeys: []`, `isEditable: false`
- MainPane: `activeThreadId: "t-1"`, `viewMode: "timeline"`, `lastEventId: "evt-0"`
- SystemStateBar: `systemStatus: "ok"`, `labels: ["local", "mocked"]`, `lastUpdatedAt: "2026-01-01T00:00:00Z"`
- ThreadHeader: `threadId: "t-1"`, `title: "Project Alpha"`, `status: "active"`, `lastEventId: "evt-0"`
- ThreadTitle: `threadId: "t-1"`, `title: "Project Alpha"`, `isEditable: false`
- ThreadActions: `availableActions: ["pin", "mute", "archive"]`, `lastInvokedAction: "none"`
- MessageTimeline: `threadId: "t-1"`, `messageIds: ["m-1", "m-2"]`, `scrollAnchor: "bottom"`, `lastEventId: "evt-0"`
- MessageBubble: `messageId: "m-1"`, `actorRole: "assistant"`, `timestamp: "2026-01-01T00:00:10Z"`, `status: "delivered"`
- MessageContent: `messageId: "m-1"`, `content: "Mocked message content."`, `format: "text"`, `attachments: []`
- MessageContextMenu: `messageId: "m-1"`, `isOpen: false`, `anchor: "none"`
- MessageComposer: `draftText: ""`, `selectedActors: ["a-3"]`, `isSubmitting: false`, `lastEventId: "evt-0"`
- ComposerInput: `draftText: ""`, `isFocused: false`, `cursorPosition: 0`
- ComposerToolbar: `availableCommands: ["/help", "/assign", "/summarize"]`, `activeCommandId: "none"`
- CommandPalette: `isOpen: false`, `query: ""`, `results: ["/help", "/assign", "/summarize"]`, `highlightedIndex: 0`
- ThreadOverviewDrawer: `threadId: "t-1"`, `isOpen: false`, `sections: ["summary", "actors", "files"]`, `activeSectionId: "summary"`
- MessageDetailsPanel: `messageId: "m-1"`, `isOpen: false`, `details: { tokens: 42, latencyMs: 120 }`
- SoundNotifier: `isEnabled: true`, `lastSoundId: "none"`, `volume: 0.6`
- OverlayManager: `activeOverlays: []`, `zStack: []`, `lastEventId: "evt-0"`

## Acceptance criteria

- `pnpx nx run client:build` produces static assets.
- `pnpx nx run client:serve` (or equivalent) serves the built client.
- Visiting the server root URL loads the mocked UI page with the full hierarchy visible.
- All components render from their initialized state with visible placeholder values.

## Testing (rendering)

- Configure Vitest in `apps/client/vite.config.ts` or `apps/client/vitest.config.ts`:
  - `test.environment = "jsdom"`
  - `test.setupFiles = ["apps/client/src/setupTests.ts"]`
- Add `apps/client/src/setupTests.ts` to include `@testing-library/jest-dom`.
- Place tests in `apps/client/src/**/__tests__/*.spec.tsx` or colocated as `apps/client/src/**/ComponentName.spec.tsx`.
- Add component render tests using React Testing Library + Vitest.
- Assert each component renders its initialized state (text, labels, badges, or placeholders).
- Add a single AppShell render test to ensure the full hierarchy mounts.
- Prefer semantic queries or `data-testid` for major regions (Sidebar, MainPane, Timeline, Composer).

## Implementation checklist

- Define React component structure in `apps/client` matching the hierarchy.
- Compose the layout in a single page with static content placeholders.
- Initialize component state with explicit default values and render those values.
- Use Effect TS types/utilities for state transition and effect modeling where it makes sense, even if not wired in v0.1.0.
- Add Vitest + React Testing Library setup for the client (jsdom + setupTests).
- Confirm `client:build` emits static assets and `client:serve` serves them.
- Update `README.md` with the new serve flow if needed.
