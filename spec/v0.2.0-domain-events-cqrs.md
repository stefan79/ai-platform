# Spec: v0.2.0 domain events + CQRS snapshots in server-core

## Summary

Introduce typed domain events for server, user, and thread aggregates, store them in DynamoDB, and maintain aggregate snapshots via a repository service. Command handling emits domain events, and a DynamoDB transaction atomically writes domain events, snapshots, and outbox records. Outbox effects are dispatched only after the transaction commits. Thread snapshots are persisted after each new message. Server snapshots track users, and user snapshots track threads.

## Goals

- Define explicit domain event types for server, user, and thread aggregates.
- Add snapshot storage and a repository API to load snapshots and apply domain events.
- Store thread snapshot on each new message.
- Use a DynamoDB transaction to atomically store domain events, snapshots, and outbox records.
- Apply outbox effects only after the transaction succeeds.
- Use `ts-pattern` (matching) and `effect` for reducer and repository flow where suitable.
- Treat the domain model as fixed; extend only command/event processing around it.
- Keep domain events intentionally separate from command and external event schemas.

## Non-goals

- Query-optimized read models or projections.
- Multi-tenant partitioning.
- Cross-aggregate sagas.

## Current state (observed)

- Domain events are created as generic payloads in `apps/server-core/src/domain/events.ts` and stored via `DynamoPersistenceService.transactDomainAndOutbox` in `apps/server-core/src/persistence/dynamo.persistence.ts`.
- `CommandProcessorService` emits `MessageReducedEvent` (NestJS CQRS event) but no projector applies domain events to any aggregate state.
- Reducers operate without loading a snapshot and do not persist snapshots.

## CQRS / NestJS CQRS usage

NestJS CQRS is in use (`@nestjs/cqrs`) for local domain-event publication (`MessageReducedEvent`). This spec keeps that pattern for in-process hooks, while DynamoDB remains the source of truth for persisted domain events and snapshots. NestJS CQRS events are non-authoritative and should not replace DynamoDB events/snapshots.

## Proposed architecture

### High-level flow

1. Command received (Kafka) -> `CommandProcessorService`.
2. Reducers load current snapshot (server/user/thread) via repository.
3. Reducers emit typed domain events and compute the next snapshot (or let repository apply events).
4. DynamoDB transaction stores domain events + snapshot + outbox records.
5. Outbox dispatcher publishes effects after transaction commit.

### Sequence diagram: command -> domain events -> outbox

```
+-------------+      +---------------------+      +-------------------+      +-----------------+
| Kafka (cmd) |----->| CommandProcessorSvc |----->| ReducerChainSvc   |----->| DomainRepo      |
+-------------+      +---------------------+      +-------------------+      +-----------------+
                                                                      |      |  TransactWrite  |
                                                                      |      |  - domain events|
                                                                      |      |  - snapshots    |
                                                                      |      |  - outbox       |
                                                                      |      +-----------------+
                                                                      |                 |
                                                                      |                 v
                                                                      |      +-----------------+
                                                                      +----->| OutboxService   |
                                                                             | publish + delete|
                                                                             +-----------------+
```

### Sequence diagram: snapshot load

```
+-------------------+      +------------------+      +------------------+
| Reducer / Handler |----->| DomainRepository |----->| DynamoDB          |
+-------------------+      +------------------+      | snapshots + events|
                                                     +------------------+
```

## Domain event model

### Event envelope

Replace the generic `DomainEventRecord` payload in `apps/server-core/src/domain/events.ts` with a typed envelope.

```ts
export type DomainAggregateType = 'server' | 'user' | 'thread';

export type DomainEventType =
  | 'server.setting-updated'
  | 'server.user-added'
  | 'user.profile-updated'
  | 'user.thread-added'
  | 'thread.message-added'
  | 'thread.title-updated'
  | 'thread.metadata-updated';

export type DomainEventEnvelope<T extends DomainEventType = DomainEventType> = {
  eventId: string;
  occurredAt: number;
  aggregateId: string;
  aggregateType: DomainAggregateType;
  type: T;
  payload: DomainEventPayloadMap[T];
  version?: number;
};
```

### Example domain payloads

```ts
export type DomainEventPayloadMap = {
  'server.setting-updated': { key: string; value: string };
  'server.user-added': { userId: string };
  'user.profile-updated': { displayName?: string; avatarUrl?: string };
  'user.thread-added': { threadId: string };
  'thread.message-added': {
    messageId: string;
    authorId: string;
    timestamp: number;
    body: string;
  };
  'thread.title-updated': { title: string };
  'thread.metadata-updated': { key: string; value: string };
};
```

### Event definitions

Domain event definitions are fixed and should live alongside other server-core schemas and use Zod for validation. Store them under `apps/server-core/src/domain/event-definitions/*.ts` or extend `apps/server-core/src/domain/events.ts` with `domainEventDefinitions` and Zod schemas. No generator is required for v0.2.0; keep schemas explicit and stable.

## Snapshot model

### Snapshot types

```ts
export type ServerSnapshot = {
  serverId: string;
  users: string[];
  settings: Record<string, string>;
  updatedAt: number;
  version: number;
};

export type UserSnapshot = {
  userId: string;
  threads: string[];
  profile: {
    displayName?: string;
    avatarUrl?: string;
  };
  updatedAt: number;
  version: number;
};

export type ThreadSnapshot = {
  threadId: string;
  userId: string;
  title?: string;
  lastMessage?: {
    messageId: string;
    authorId: string;
    timestamp: number;
    body: string;
  };
  updatedAt: number;
  version: number;
};
```

### Snapshot policy

- Persist `ThreadSnapshot` on every `thread.message-added` domain event.
- Persist `ServerSnapshot` and `UserSnapshot` only when a domain event for the aggregate is emitted.
- Use monotonic snapshot versions (increment per aggregate). Start new snapshots at `version: 0`.
- Messages are stored only on threads; there are no messages without a thread.
- Server settings are global (single server aggregate).
- Thread snapshots are thin (metadata + lastMessage). Message lists are derived from domain events.
-
## Proof-of-concept scope

- Implement the minimal command/event flow for threads and messages.
- Leave full server/user lifecycle and thread creation details for follow-up specs.
- Seed a single thread snapshot in local infrastructure to accept messages during the PoC.
- Infrastructure setup should create the snapshots table and the domain-change topic.

## Repository API

Add a repository service (example path `apps/server-core/src/domain/repository/domain-repository.ts`) that encapsulates snapshot loads and writes.

```ts
export interface DomainRepository {
  loadServer(serverId: string): Promise<ServerSnapshot | null>;
  loadUser(userId: string): Promise<UserSnapshot | null>;
  loadThread(threadId: string): Promise<ThreadSnapshot | null>;

  listThreads(args: {
    userId: string;
    limit?: number;
    cursor?: string;
    direction?: 'forward' | 'backward';
    sort?: string;
    order?: 'asc' | 'desc';
    filter?: Record<string, string>;
  }): Promise<{ items: ThreadSnapshot[]; cursor?: string }>;

  listThreadMessages(args: {
    userId: string;
    threadId: string;
    limit?: number;
    cursor?: string;
    direction?: 'forward' | 'backward';
    sort?: string;
    order?: 'asc' | 'desc';
    filter?: Record<string, string>;
  }): Promise<{ items: DomainEventPayloadMap['thread.message-added'][]; cursor?: string }>;

  transact(
    events: DomainEventEnvelope[],
    snapshots: Array<ServerSnapshot | UserSnapshot | ThreadSnapshot>,
    outbox: OutboxRecord[],
  ): Promise<void>;
}
```

Implement `transact` with DynamoDB `TransactWriteCommand` to atomically persist all records. List/query parameters should align with server-rest paging/sorting/filtering conventions from `apps/server-rest/AGENTS.md`.

## DynamoDB data model

Add a snapshot table and adjust event/outbox items for efficient access.

- Domain events table: `ai-platform-domain-events`
  - `pk`: `AGG#<aggregateType>#<aggregateId>`
  - `sk`: `EVENT#<occurredAt>#<eventId>`
  - Attributes: `type`, `payload`, `occurredAt`, `version`, `eventId`

- Snapshots table: `ai-platform-snapshots`
  - `pk`: `AGG#<aggregateType>#<aggregateId>`
  - `sk`: `SNAPSHOT#<version>`
  - Attributes: full snapshot payload

- Outbox table: `ai-platform-outbox`
  - `pk`: `OUTBOX#<id>`
  - `sk`: `OUTBOX#<createdAt>`
  - Attributes: `type`, `payload`, `createdAt`

If staying with the current schema-less layout, add GSI(s) later when query requirements appear.

For message paging in the PoC, query the domain events table for `aggregateType=thread` + `aggregateId=<threadId>` and filter `type=thread.message-added`, using `sk` for pagination and ordering.

## Command handling changes

### Thread invariants

- Messages must only be written to existing threads. `command.save-user-message` should fail if the thread snapshot does not exist.
- Thread creation is out of scope here but should emit `user.thread-added` and produce a `ThreadSnapshot` with `userId` set at creation time.

### Reducer flow

Update reducers to load aggregate state before producing events. For example, `SaveUserMessageCommandHandler` can switch to `thread.message-added` and compute a thread snapshot.

```ts
const thread = await repository.loadThread(command.payload.threadId);
const userId = context.userId ?? context.sessionId;
if (!thread) {
  throw new Error('Thread not found');
}
const event: DomainEventEnvelope<'thread.message-added'> = {
  eventId: randomUUID(),
  occurredAt: Date.now(),
  aggregateId: command.payload.threadId,
  aggregateType: 'thread',
  type: 'thread.message-added',
  payload: {
    messageId: command.payload.messageId,
    authorId: userId,
    timestamp: command.payload.timestamp,
    body: command.payload.body,
  },
};

const nextThread = applyThreadEvent(thread, event);

return {
  domainEvents: [event],
  snapshots: [nextThread],
  outboxRecords: [],
};
```

### Apply functions

```ts
export function applyThreadEvent(
  snapshot: ThreadSnapshot,
  event: DomainEventEnvelope<'thread.message-added' | 'thread.title-updated' | 'thread.metadata-updated'>,
): ThreadSnapshot {
  switch (event.type) {
    case 'thread.message-added':
      return {
        ...snapshot,
        lastMessage: event.payload,
        updatedAt: event.occurredAt,
        version: snapshot.version + 1,
      };
    case 'thread.title-updated':
      return {
        ...snapshot,
        title: event.payload.title,
        updatedAt: event.occurredAt,
        version: snapshot.version + 1,
      };
    case 'thread.metadata-updated':
      return { ...snapshot, updatedAt: event.occurredAt, version: snapshot.version + 1 };
  }
}
```

### ts-pattern + effect usage

Reducers and repository composition should use `ts-pattern` and `effect` to align with current code style.

```ts
import { match } from 'ts-pattern';
import { Effect } from 'effect';

const applyThreadEvent = (snapshot: ThreadSnapshot, event: DomainEventEnvelope) =>
  match(event)
    .with({ type: 'thread.message-added' }, (evt) => ({
      ...snapshot,
      lastMessage: evt.payload,
      updatedAt: evt.occurredAt,
      version: snapshot.version + 1,
    }))
    .with({ type: 'thread.title-updated' }, (evt) => ({
      ...snapshot,
      title: evt.payload.title,
      updatedAt: evt.occurredAt,
      version: snapshot.version + 1,
    }))
    .with({ type: 'thread.metadata-updated' }, (evt) => ({
      ...snapshot,
      updatedAt: evt.occurredAt,
      version: snapshot.version + 1,
    }))
    .exhaustive();

const reduceThreadMessage = (input: ReduceInput) =>
  Effect.gen(function* () {
    const thread = yield* Effect.tryPromise(() => repository.loadThread(input.threadId));
    if (!thread) {
      return yield* Effect.fail(new Error('Thread not found'));
    }
    const event = buildThreadMessageEvent(input, thread);
    const snapshot = applyThreadEvent(thread, event);
    return { events: [event], snapshots: [snapshot], outbox: [] };
  });
```

### Transaction and outbox

Extend `ReductionResult` to include `snapshots` and use a single transaction write.

```ts
export interface ReductionResult {
  domainEvents: DomainEventEnvelope[];
  snapshots: Array<ServerSnapshot | UserSnapshot | ThreadSnapshot>;
  outboxRecords: OutboxRecord[];
}
```

`OutboxService.persistAndDispatch` should call `DomainRepository.transact(...)` and only publish after a successful transaction.

## Transaction rules

- Write domain events, snapshots, and outbox records in one DynamoDB `TransactWriteCommand`.
- Use conditional expressions to avoid duplicate event IDs if a command is re-processed.
- Track snapshot versions (monotonic, per aggregate) but do not enforce version checks yet.
- Only dispatch outbox records after transaction success.
- On dispatch failure, keep outbox records and retry (current behavior already deletes only on success).

## Domain change topic (automatic effects)

To reduce manual registration and keep external consumers in sync, emit domain events as effects on a dedicated domain-change topic. This can be automated by having the outbox dispatcher publish any `DomainEventEnvelope` as an effect without an explicit per-event registration.

### Proposed behavior

- Every persisted domain event is also enqueued into the outbox as `type: 'kafka.domain-change'`.
- The dispatcher publishes to a new `KAFKA_DOMAIN_CHANGES_TOPIC` (default `ai-platform-domain-changes`).
- No manual registration: the outbox service converts domain events -> effect payloads generically.
-
### Transaction placement

- Domain-change outbox records are created alongside other effects and committed in the same DynamoDB transaction as the domain events and snapshots.

### Example outbox payload

```ts
export type DomainChangeEnvelope = {
  id: string;
  ts: number;
  type: 'domain.change';
  aggregateType: DomainAggregateType;
  aggregateId: string;
  domainEvent: DomainEventEnvelope;
};
```

### Topic details

- Topic name: `KAFKA_DOMAIN_CHANGES_TOPIC` (default `ai-platform-domain-changes`).
- Message key: `aggregateId` to preserve per-aggregate ordering.
- Message value: `DomainChangeEnvelope`.
- Intended consumers: server-ws, server-rest snapshot bootstrap, analytics.

### Tasks

- Add a new outbox effect type `kafka.domain-change`.
- Add `KAFKA_DOMAIN_CHANGES_TOPIC` config and topic wiring in `apps/server-core/src/config.ts`.
- Extend reducers or repository to auto-enqueue domain-change effects alongside other effects so they are written in the same DynamoDB transaction.

## Acceptance criteria

- Domain events are typed and scoped to server/user/thread aggregates.
- Thread snapshot stored after each message (user or assistant).
- Server snapshot stores users; user snapshot stores threads.
- DynamoDB transaction stores domain events, snapshots, and outbox records together.
- Outbox effects are dispatched only after transaction commit.
- Domain-change outbox effects are emitted automatically for all domain events.
- Repository can load snapshots for server/user/thread.

## Implementation notes (targeted files)

- `apps/server-core/src/domain/events.ts`: replace generic `CoreMessageBody` payload with typed domain events.
- `apps/server-core/src/command/handlers/save-user-message.command.ts`: emit `thread.message-added` and compute snapshot.
- `apps/server-core/src/command/handlers/reply-with-assistant-message.command.ts`: emit `thread.message-added` for assistant message + snapshot.
- `apps/server-core/src/command/outbox.service.ts`: transaction should include snapshots.
- `apps/server-core/src/persistence/dynamo.persistence.ts`: add snapshot table support + composite keys.
- `apps/server-core/src/domain/reducers/reducer-chain.service.ts`: allow reducers to return snapshots.

## Open questions

- Should `user.thread-added` be emitted on thread creation only, or also on first message?
- Do we want to maintain an explicit user->thread relationship on server snapshot only, or also on user snapshot?
